<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="弥生">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="弥生">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="弥生">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>弥生</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">弥生</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-首页">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-分类">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-文章">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            文章
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/31/Babel介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="弥生的狗子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="弥生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/31/Babel介绍/" itemprop="url">Babel介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-31T09:22:25+08:00">
                2018-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/项目搭建相关/" itemprop="url" rel="index">
                    <span itemprop="name">项目搭建相关</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Babel的作用"><a href="#Babel的作用" class="headerlink" title="Babel的作用"></a>Babel的作用</h3><p>简单来说把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="使用单体文件"><a href="#使用单体文件" class="headerlink" title="使用单体文件"></a>使用单体文件</h4><h4 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h4><p>多见于 package.json 中的 scripts 段落中的某条命令</p>
<h4 id="构建工具的插件"><a href="#构建工具的插件" class="headerlink" title="构建工具的插件"></a>构建工具的插件</h4><p>直接集成到构建工具中</p>
<h3 id="Babel工作流程"><a href="#Babel工作流程" class="headerlink" title="Babel工作流程"></a>Babel工作流程</h3><p>babel 本身不具有任何转化功能，它把转化的功能都分解到一个个 plugin 里面。因此当我们不配置任何插件时，经过 babel 的代码和输入是相同的</p>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><h4 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h4><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul>
<li>将插件的名字增加到配置文件中 (根目录下创建 .babelrc 或者 package.json 的 babel 里面，格式相同)</li>
<li>使用 npm install babel-plugin-xxx 进行安装<h4 id="preset"><a href="#preset" class="headerlink" title="preset"></a>preset</h4>比如 es2015 是一套规范，包含大概十几二十个转译插件。如果每次要开发者一个个添加并安装，配置文件很长不说，npm install 的时间也会很长<br>为了解决这个问题，babel 还提供了一组插件的集合。因为常用，所以不必重复定义 &amp; 安装<br>preset 分为以下几种:<br>官方presets:</li>
<li>@babel/preset-env</li>
<li>@babel/preset-flow</li>
<li>@babel/preset-react</li>
<li>@babel/preset-typescript</li>
<li>…<br>Stage-X (Experimental Presets)</li>
<li>Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。</li>
<li>Stage 1 - 提案: 初步尝试。</li>
<li>Stage 2 - 初稿: 完成初步规范。</li>
<li>Stage 3 - 候选: 完成规范和浏览器初步实现。</li>
<li>Stage 4 - 完成: 将被添加到下一年度发布。<br>此外，低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。<br>stage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。<h4 id="插件和-preset-的配置项"><a href="#插件和-preset-的配置项" class="headerlink" title="插件和 preset 的配置项"></a>插件和 preset 的配置项</h4>简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;presets&quot;: [</span><br><span class="line">    // 带了配置项，自己变成数组</span><br><span class="line">    [</span><br><span class="line">        // 第一个元素依然是名字</span><br><span class="line">        &quot;env&quot;,</span><br><span class="line">        // 第二个元素是对象，列出配置项</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;module&quot;: false</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    // 不带配置项，直接列出名字</span><br><span class="line">    &quot;stage-2&quot;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="插件执行顺序"><a href="#插件执行顺序" class="headerlink" title="插件执行顺序"></a>插件执行顺序</h3><ul>
<li>Plugin 会运行在 Preset 之前。</li>
<li>Plugin 会从前到后顺序执行。</li>
<li>Preset 的顺序则 刚好相反(从后向前)。</li>
</ul>
<h3 id="env"><a href="#env" class="headerlink" title="env"></a>env</h3><p>env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。例如目标浏览器支持 es2015，那么 es2015 这个 preset 其实是不需要的，于是代码就可以小一点(一般转化后的代码总是更长)，构建时间也可以缩短一些。<br>如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [&quot;env&quot;, &#123;</span><br><span class="line">      &quot;targets&quot;: &#123;</span><br><span class="line">        &quot;browsers&quot;: [&quot;last 2 versions&quot;, &quot;safari &gt;= 7&quot;]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上配置将考虑所有浏览器的最新2个版本(safari大于等于7.0的版本)的特性，将必要的代码进行转换。而这些版本已有的功能就不进行转化了<br>具体写法参照<a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener">官网</a>或者<a href="https://github.com/browserslist/browserslist" target="_blank" rel="noopener">browserslist</a>。条件对应的环境可以在这里<a href="http://browserl.ist/" target="_blank" rel="noopener">查询</a></p>
<p>另外一个有用的配置项是 modules。它的取值可以是 amd, umd, systemjs, commonjs 和 false。这可以让 babel 以特定的模块化格式来输出代码。如果选择 false 就不进行模块化处理。</p>
<h3 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h3><p>babel 默认只转换 js 语法，而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法(比如 Object.assign)都不会转码。<br>举例来说，es2015 在 Array 对象上新增了 Array.from 方法。babel 就不会转码这个方法。如果想让这个方法运行，必须使用 babel-polyfill。(内部集成了 core-js 和 regenerator)<br>使用时，在所有代码运行之前增加 require(‘babel-polyfill’)。或者更常规的操作是在 webpack.config.js 中将 babel-polyfill 作为第一个 entry。因此必须把 babel-polyfill 作为 dependencies 而不是 devDependencies<br>babel-polyfill 主要有两个缺点：</p>
<ul>
<li>使用 babel-polyfill 会导致打出来的包非常大，因为 babel-polyfill 是一个整体，把所有方法都加到原型链上。比如我们只使用了 Array.from，但它把 Object.defineProperty 也给加上了，这就是一种浪费了。这个问题可以通过单独使用 core-js 的某个类库来解决，core-js 都是分开的。</li>
<li>babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。</li>
</ul>
<p>因此在实际使用中，如果我们无法忍受这两个缺点(尤其是第二个)，通常我们会倾向于使用 babel-plugin-transform-runtime。<br>但如果代码中包含高版本 js 中类型的实例方法 (例如 [1,2,3].includes(1))，这还是要使用 polyfill。</p>
<h3 id="babel-runtime-和-babel-plugin-transform-runtime"><a href="#babel-runtime-和-babel-plugin-transform-runtime" class="headerlink" title="babel-runtime 和 babel-plugin-transform-runtime"></a>babel-runtime 和 babel-plugin-transform-runtime</h3><p>我们时常在项目中看到 .babelrc 中使用 babel-plugin-transform-runtime，而 package.json 中的 dependencies (注意不是 devDependencies) 又包含了 babel-runtime，那这两个是不是成套使用的呢？他们又起什么作用呢？</p>
<p>先说 babel-plugin-transform-runtime。</p>
<p>babel 会转换 js 语法，之前已经提过了。以 async/await 举例，如果不使用这个 plugin (即默认情况)，转换后的代码大概是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// babel 添加一个方法，把 async 转化为 generator</span><br><span class="line">function _asyncToGenerator(fn) &#123; return function () &#123;....&#125;&#125; // 很长很长一段</span><br><span class="line"></span><br><span class="line">// 具体使用处</span><br><span class="line">var _ref = _asyncToGenerator(function* (arg1, arg2) &#123;</span><br><span class="line">  yield (0, something)(arg1, arg2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这个 _asyncToGenerator 在当前文件被定义，然后被使用了，以替换源代码的 await。但每个被转化的文件都会插入一段 _asyncToGenerator 这就导致重复和浪费了。</p>
<p>在使用了 babel-plugin-transform-runtime 了之后，转化后的代码会变成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 从直接定义改为引用，这样就不会重复定义了。</span><br><span class="line">var _asyncToGenerator2 = require(&apos;babel-runtime/helpers/asyncToGenerator&apos;);</span><br><span class="line">var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);</span><br><span class="line"></span><br><span class="line">// 具体使用处是一样的</span><br><span class="line">var _ref = _asyncToGenerator3(function* (arg1, arg2) &#123;</span><br><span class="line">  yield (0, something)(arg1, arg2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>从定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。</p>
<p>但在这里，我们也发现 babel-runtime 出场了，它就是这些方法的集合处，也因此，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。</p>
<p>再说 babel-runtime，它内部集成了</p>
<ul>
<li>core-js: 转换一些内置类 (Promise, Symbols等等) 和静态方法 (Array.from 等)。绝大部分转换是这里做的。自动引入。</li>
<li>regenerator: 作为 core-js 的拾遗补漏，主要是 generator/yield 和 async/await 两组的支持。当代码中有使用 generators/async 时自动引入。</li>
<li>helpers, 如上面的 asyncToGenerator 就是其中之一，其他还有如 jsx, classCallCheck 等等，可以查看 babel-helpers。在代码中有内置的 helpers 使用时(如上面的第一段代码)移除定义，并插入引用(于是就变成了第二段代码)。<br>babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1))</li>
</ul>
<h3 id="Babel-7-x"><a href="#Babel-7-x" class="headerlink" title="Babel 7.x"></a>Babel 7.x</h3><h4 id="preset-的变更：淘汰-es201x，删除-stage-x，强推-env-重点"><a href="#preset-的变更：淘汰-es201x，删除-stage-x，强推-env-重点" class="headerlink" title="preset 的变更：淘汰 es201x，删除 stage-x，强推 env (重点)"></a>preset 的变更：淘汰 es201x，删除 stage-x，强推 env (重点)</h4><p>淘汰 es201x 的目的是把选择环境的工作交给 env 自动进行，而不需要开发者投入精力。凡是使用 es201x 的开发者，都应当使用 env 进行替换。但这里的淘汰 (原文 deprecated) 并不是删除，只是不推荐使用了，不好说 babel 8 就真的删了。</p>
<p>与之相比，stage-x 就没那么好运了，它们直接被删了。这是因为 babel 团队认为为这些 “不稳定的草案” 花费精力去更新 preset 相当浪费。stage-x 虽然删除了，但它包含的插件并没有删除(只是被更名了，可以看下面一节)，我们依然可以显式地声明这些插件来获得等价的效果。完整列表</p>
<p>为了减少开发者替换配置文件的机械工作，babel 开发了一款 babel-upgrade 的工具，它会检测 babel 配置中的 stage-x 并且替换成对应的 plugins。除此之外它还有其他功能，我们一会儿再详细看。(总之目的就是让你更加平滑地迁移到 babel 7)</p>
<h4 id="npm-package-名称的变化"><a href="#npm-package-名称的变化" class="headerlink" title="npm package 名称的变化"></a>npm package 名称的变化</h4><p>这是 babel 7 的一个重大变化，把所有 babel-<em> 重命名为 @babel/</em>，例如：</p>
<p>babel-cli 变成了 @babel/cli。<br>babel-preset-env 变成了 @babel/preset-env。进一步，还可以省略 preset 而简写为 @babel/env。<br>babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions。和 preset 一样，plugin 也可以省略，于是简写为 @babel/transform-arrow-functions。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/25/git操作记录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="弥生的狗子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="弥生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/25/git操作记录/" itemprop="url">git操作记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-25T09:19:38+08:00">
                2018-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/工具方法/" itemprop="url" rel="index">
                    <span itemprop="name">工具方法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>git作为最常用的版本控制工具，重要性不言而喻。平时使用的时候有些命令并没有非常理解使用场景，此文用来记录git的操作和其使用场景，以及git的一些概念。</p>
<h2 id="会生成版本的操作"><a href="#会生成版本的操作" class="headerlink" title="会生成版本的操作"></a>会生成版本的操作</h2><p>1、commit<br>2、非fast forward模式的分支合并<br>注：fast forward模式：比如从master上拉出一个dev分支，dev分支进行了多次commit，而后将dev分支合并到，在dev分支合并到master之前master分支没有任何提交，这个情况下，git会采用fast forward模式进行merge。采用这种模式，如果将dev分支删除之后不会分支的信息将会丢失。当然我们可以使用–no-ff 强制禁止使用fast forward模式。</p>
<h2 id="提交类操作"><a href="#提交类操作" class="headerlink" title="提交类操作"></a>提交类操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;file&gt;/.   // 将本地变更提交到暂存区(stage)</span><br><span class="line">git commit -m &quot;&lt;message&gt;&quot;   // 将暂存区(stage)内容一次性提交到本地仓库中，生成一次新的提交</span><br><span class="line">git push &lt;branch&gt;  // 将本地仓库的修改提交到远端仓库</span><br></pre></td></tr></table></figure>
<h2 id="暂存类操作"><a href="#暂存类操作" class="headerlink" title="暂存类操作"></a>暂存类操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git stash  // 将工作区改动临时存储起来</span><br><span class="line">git stash list // 查看临时存储的信息</span><br><span class="line">git stash apply // 将最近一次放入临时存储区域的改动取出，临时存储区域该次存储不删除</span><br><span class="line">git stash drop &lt;version&gt;  // 删除某次存入存储区域的改动</span><br><span class="line">git stash pop  //  将最近一次放入临时存储区域的改动取出，临时存储区域该次存储会被删除</span><br></pre></td></tr></table></figure>
<h2 id="关联操作"><a href="#关联操作" class="headerlink" title="关联操作"></a>关联操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin bug  // 本地新建分支，远端没有该分支，这样push可以在远端新建对应跟踪分支</span><br></pre></td></tr></table></figure>
<h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=oneline  // 查看当前分支所有版本信息</span><br><span class="line">git reflog  // 查看每一次git操作，包括 commit checkout reset merge</span><br><span class="line">git status  // 查看当前分支的状态</span><br><span class="line">git remote -v  // 查看远程分支的信息，包括fetch和push地址</span><br></pre></td></tr></table></figure>
<h2 id="撤销回退操作"><a href="#撤销回退操作" class="headerlink" title="撤销回退操作"></a>撤销回退操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD/version // 当前分支回退到对应版本，HEAD^表示上一版本，HEAD^^, HEAD~100,一次类推</span><br><span class="line">git checkout -- &lt;file&gt;/*  // 撤销未提交到暂存区(stage)的工作区内容的改动</span><br><span class="line">git reset HEAD &lt;file&gt;/*   // 将暂存区(stage)的内容回送回到工作区(unstage),然后可以使用git checkout -- &lt;file&gt;/* 撤销此次的内容改动</span><br></pre></td></tr></table></figure>
<h2 id="切换操作"><a href="#切换操作" class="headerlink" title="切换操作"></a>切换操作</h2><p>git checkout <branch>  // 切换分支<br>git checkout -b <branch> // 新建分支并切换到新建的分支</branch></branch></p>
<h2 id="新建操作"><a href="#新建操作" class="headerlink" title="新建操作"></a>新建操作</h2><p>git branch <branch> // 新建分支</branch></p>
<h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>git branch -d <branch>  // 删除分支<br>git branch -D <branch>  // 强制删除</branch></branch></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/18/WebAssembly介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="弥生的狗子">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="弥生">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/18/WebAssembly介绍/" itemprop="url">WebAssembly介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-18T20:55:37+08:00">
                2018-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/框架及技术/" itemprop="url" rel="index">
                    <span itemprop="name">框架及技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>WebAssembly or wasm is a new portable, size- and load-time-efficient format suitable for compilation to the web.</p>
<p>以上是<a href="http://webassembly.org/" target="_blank" rel="noopener">WebAssemby</a>官网对WebAssemby的定义，翻译过来的大概是这个意思</p>
<p>WebAssembly(简称wasm)是一种精简的、大小和加载时间高效的数据格式，适合编译到Web上运行。</p>
<p>这句话的几个关键词概括出了wasm的一些特点。</p>
<p>加载高效：WebAssembly被设计成体积很小的二进制格式，所以加载高效。 </p>
<p>Web上运行：WebAssembly 是除了 JavaScript 以外，另一种可以在浏览器中执行的编程语言。</p>
<p>总结起来，WebAssembly是一种二进制格式的类汇编语言，可以被浏览器加载，并进一步编译成可执行的机器码，从而在客户端运行，因此的执行效率比javascript高很多。</p>
<h2 id="为什么会出现WebAssembly"><a href="#为什么会出现WebAssembly" class="headerlink" title="为什么会出现WebAssembly"></a>为什么会出现WebAssembly</h2><p>随着现代WEB应用的复杂度逐渐变高，对JavaScript的执行效率提出了更高的要求，而JavaScript作为一门解释性语言，性能是存在瓶颈的。这也是WebAssembly出现的主要原因。下面我们分析下JavaScript的性能瓶颈主要在哪几个点上。</p>
<p>高级语言一般可以分为解释性和编译性语言两种，解释性语言通过解释器翻译成机器码，而编译性语言通过编译器翻译成机器码。</p>
<p>解释器启动和执行的更快。不需要等待所有代码解释完成就可以运行你的代码。从第一行开始翻译，就可以依次继续执行了。但是当你运行一个循环，同样的代码需要多次运行时，解释器会一次一次的解释这段代码，导致其效率低下。</p>
<p>而编译器和解释器正好相反，它会首先将整个文件的源代码编译成目标代码，所以并不会重复去编译循环中的代码。并且编译器在编译的过程中可以对代码进行优化，所以执行效率会高很多。但是其启动执行时间会慢一些。</p>
<p>为了解决JavaScript的低效问题，很多JavaScript解析引擎将Just-in-time（简称JIT）编译器引入了JS引擎之中，形成了一种混合引擎，综合解释器和编译器的优点。</p>
<p>主要的一个原理是，JavaScript引擎中会引入一个监视器，当监视器发现同一行代码被运行了很多次之后，就会对这行代码做上标记，并把这行代码送到基线编译器里去编译，把结果存储起来。下一次当监视器发现同一行代码再次执行时，就不需要对它进行解析，而是将已经编译好的结果传给浏览器执行即可。通常这样的做法都可以提高代码的执行效率。</p>
<p>上文我们提到，编译器是可以对代码进行一定程度的优化的，当一段代码被执行了多次执行之后，就可能被送到优化编译器里进行优化，并将结果存储起来。优化后的代码段再次执行之前，编译器会检查此次代码是否与优化代码一致，如果发现变量类型变化的情况，那么编译器便会把优化的代码丢弃，重新对代码进行解析，这个过程叫做“去优化”。</p>
<p>总的来说，虽然浏览器引入JIT可以大大提高JavaScript的执行性能，但是也会增加一些开销：<br>1、优化和去优化开销；<br>2、监视器记录信息对内存的开销；<br>3、发生去优化情况时恢复信息的记录对内存的开销；<br>4、对基线版本和优化后版本记录的内存开销。</p>
<p>所以JavaScript还是有优化的空间，这是WebAssembly出现的一个主要原因。</p>
<h2 id="WebAssembly的工作原理"><a href="#WebAssembly的工作原理" class="headerlink" title="WebAssembly的工作原理"></a>WebAssembly的工作原理</h2><p>我们首先介绍下高级语言到汇编语言的一个翻译过程。<br>高级语言翻译成汇编语言的流程如下图（出处见底部）：</p>
<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/04-01-langs09.png" alt=""></p>
<p>编译器的front-end部分首先会将高级语言翻译成一种中间代码（intermediate representation，IR），而后编译器的back-end部分将IR翻译成对应目标机器的汇编代码。不用的机器结构会对应不同的汇编语言的结构（x86、ARM）。所以一种汇编语言是不能在不同机构的机器上执行的，一种汇编语言对应一种机器结构，也就是说在代码到达客户端之前，我们不能将其编译成汇编代码，因为需要知道客户端的机器结构才能够正确的将代码编译成对应的汇编代码。</p>
<p>而WebAssembly 与其他的汇编语言不太一样，它不依赖于具体的物理机器。可以抽象地理解成它 是概念机器的机器语言，而不是实际的物理机器的机器语言。浏览器把 WebAssembly 下载下来后，可以迅速地将其转换成对应机器汇编代码。 WebAssembly 在代码编译过程的位置如下图(图片来源见底部)所示：</p>
<p><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/04-02-langs08.png" alt=""></p>
<p>生成 WebAssembly 的方式有多种，可以直接手写，因为 WebAssembly 提供了文本形式，写起来跟汇编差不多（如果你愿意写的话233）。更通行的方式是将用其它语言——目前主要是静态语言（C、C++、Rust等）编写的代码编译成 WebAssembly（.wasm），编译工具最主要的是 LLVM。</p>
<p>LLVM 编译的基本工作机制是：首先使用一种针对特定语言的插件（类似于 webpack 中的 loader）将该语言编译为一种中间态形式（IR），然后再由 LLVM 对 IR 进一步编译、优化，从而得到.wasm。当然也有其它的编译工具，如 Emscripten、Binaryen 等。</p>
<p>目前 .wasm文件 需要由 JS 引入后才能运行，JS 中有一个用于操作二进制代码的 API：ArrayBuffer，JS 使用 ArrayBuffer 加载 .wasm文件，然后调用编译方法，然后再创建实例。WebAssembly 还没有集成 Web API，要调用 Web API，就必须借助 JS。未来计划允许 WebAssembly 直接调用 Web API，并且让 .wasm文件模块像 ES6 模块一样易于使用。</p>
<h2 id="为什么WebAssembly会更快"><a href="#为什么WebAssembly会更快" class="headerlink" title="为什么WebAssembly会更快"></a>为什么WebAssembly会更快</h2><p>前文介绍过JavaScript解析执行过程大致如下图所示：<br><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/05-01-diagram_now01.png" alt=""></p>
<p>1、Parsing——表示把源代码变成解释器可以运行的代码所花的时间；<br>2、Compiling + optimizing——表示基线编译器和优化编译器花的时间。一些优化编译器的工作并不在主线程运行，不包含在这里。<br>3、Re-optimizing——当 JIT 发现优化假设错误，丢弃优化代码所花的时间。包括重优化的时间、抛弃并返回到基线编译器的时间。<br>4、Execution——执行代码的时间。<br>5、Garbage collection——垃圾回收，清理内存的时间。</p>
<p>WebAssembly的执行过程与JS执行过程对比图如下图：<br><img src="https://2r4s9p1yi1fa2jd7j43zph8r-wpengine.netdna-ssl.com/files/2017/02/05-03-diagram_future01.png" alt=""></p>
<p><strong>文件获取</strong>：图中没有展示这个过程，压缩后的 WebAssembly 的二进制代码比压缩后的JS代码小，使得其在服务端和客户端之间的传输时间会短一些。</p>
<p><strong>解析</strong>：JS在被执行之前是需要先转化成中间代码的，而WebAssembly本身就是就是一种中间代码，所以并不需要这个过程。</p>
<p><strong>编译和优化</strong>：JS是弱类型语言，当传入的变量发生类型变化时，同样的代码是需要编译成不同的版本的，而WebAssembly不存在这个问题，此外在编译优化代码之前，它不需要提前运行代码以知道变量都是什么类型。这都使得WebAssembly编译和优化过程比JS快很多。</p>
<p><strong>重优化</strong>：前面提到过，JS在优化的过程中是存在“去优化”的过程，所以去优化之后的代码可能会被“重优化”，反复做几次无用功，导致优化资源被占用，降低执行效率。在 WebAssembly 中，类型都是确定了的，不会存在这样的问题。</p>
<p><strong>垃圾回收</strong>：JavaScript 中，开发者不需要手动清理内存中不用的变量。JS 引擎会自动地做这件事情，这个过程叫做垃圾回收。目前的大多数浏览器已经能给垃圾回收安排一个合理的启动时间，不过这还是会增加代码执行的开销。而WebAssembly 不支持垃圾回收。内存操作都是手动控制的（像 C、C++一样）。这对于开发者来讲确实增加了些开发成本，不过这也使代码的执行效率更高。不过这一点仁者见仁了。</p>
<p>以上就是为什么WebAssembly比JS执行效率更高的原因。</p>
<p><strong>那么WebAssembly究竟有多快呢？</strong></p>
<p>Kamaron Peterson做了一个测试(<a href="https://www.lucidchart.com/techblog/2017/05/16/webassembly-overview-so-fast-so-fun-sorta-difficult/" target="_blank" rel="noopener">链接</a>)<br>他分别使用WebAssembly和JS写了一个3D的动画效果<br><img src="https://d2slcw3kip6qmk.cloudfront.net/marketing/blog/2017Q2/WASM1.png" alt=""></p>
<p>然后在不同浏览器和不同操作系统上测试了动画的运行时间，测试结果如下:<br><img src="https://d2slcw3kip6qmk.cloudfront.net/marketing/blog/2017Q2/WASMTable.png" alt=""></p>
<p>从结果中可以看出，WebAssembly的执行效率大概是JS的十倍。</p>
<h2 id="WebAssembly的发展情况"><a href="#WebAssembly的发展情况" class="headerlink" title="WebAssembly的发展情况"></a>WebAssembly的发展情况</h2><p>WebAssembly是由W3C牵头，四大浏览器厂商（谷歌、火狐、微软、苹果）共同参与的项目，可以说是JavaScript性能问题的终极解决方案，前途可谓是一片光明。</p>
<p>2015.04  <a href="WebAssembly Community Group started">WebAssembly Community Group</a> 成立<br>2015.06  第一个版本发布<br>2016.03  具有多个可互操作实现的核心特征的定义<a href="https://blogs.windows.com/msedgedev/2016/03/15/previewing-webassembly-experiments" target="_blank" rel="noopener">[1]</a><a href="https://v8project.blogspot.com/2016/03/experimental-support-for-webassembly.html" target="_blank" rel="noopener">[2]</a><a href="https://hacks.mozilla.org/2016/03/a-webassembly-milestone/" target="_blank" rel="noopener">[3]</a><br>2016.10  浏览器preview宣布多个可互操作实现<a href="https://blogs.windows.com/msedgedev/2016/10/31/webassembly-browser-preview/" target="_blank" rel="noopener">[1]</a><a href="http://v8project.blogspot.com/2016/10/webassembly-browser-preview.html" target="_blank" rel="noopener">[2]</a><a href="https://hacks.mozilla.org/2016/10/webassembly-browser-preview" target="_blank" rel="noopener">[3]</a><br>2017.02  官方logo发布<br>2017.03 <a href="https://lists.w3.org/Archives/Public/public-webassembly/2017Feb/0002.html" target="_blank" rel="noopener"> Cross-browser consensus </a>以及浏览器preview结束</p>
<p>随着浏览器preview的结束，各大浏览器厂商分别宣布MVP版本的正式上线，这就表明浏览器已经可以稳定运行WebAssembly了，开发者可以在浏览器上加载WebAssembly。</p>
<p>WebAssembly未来的<a href="http://webassembly.org/roadmap/" target="_blank" rel="noopener">规划</a></p>
<h2 id="WebAssembly会代替JavaScript嘛？"><a href="#WebAssembly会代替JavaScript嘛？" class="headerlink" title="WebAssembly会代替JavaScript嘛？"></a>WebAssembly会代替JavaScript嘛？</h2><p>这个问题应该是很多JavaScript开发者非常关心的一个问题。</p>
<blockquote>
<p>No! WebAssembly is designed to be a complement to, not replacement of, JavaScript. While WebAssembly will, over time, allow many languages to be compiled to the Web, JavaScript has an incredible amount of momentum and will remain the single, privileged (as described above) dynamic language of the Web.</p>
</blockquote>
<p>以上是官方给出的回答，大致意思是说WebAssembly的出现是对JS的一种补充，并不会也不可能替代JS，随着时间的推移，WebAssembly将允许将许多语言编译到Web上，而JavaScript作为一种运行在Web上的动态语言，仍然会保持着它的优势。</p>
<p>WebAssembly的出现其实是希望在Web应用程序的关键性能点对Web程序进行优化，采用WebAssembly编码对可能存在性能热点的地方进行重构，从而整体提高WEB程序的效率。例如，正在开发 React 程序的团队可以把虚拟 DOM、diff算法部分的代码替换成 WebAssembly 的版本，从而提高react渲染的效率。这样的一种混合方式并不会改变以JS为主的前端开发方式，但是可以大大提高性能。并且这样的WebAssembly代码之后会是以模块的形式出现，只需要在项目中引用模块即可，就像引入一个ES6的模块一样方便。</p>
<p>所以WebAssembly并不会也不可能取代JS。</p>
<h2 id="WebAssembly仅仅适用于C-C-开发者嘛？"><a href="#WebAssembly仅仅适用于C-C-开发者嘛？" class="headerlink" title="WebAssembly仅仅适用于C/C++开发者嘛？"></a>WebAssembly仅仅适用于C/C++开发者嘛？</h2><p>虽然WebAssembly目前仅仅支持C/C++/Rust这几种语言进行编译，但是这么做的目的仅仅是为了尽快出了一个稳定的MVP版本而做出的折衷的选择。之后会继续支持其他语言的编译（<a href="http://webassembly.org/docs/high-level-goals/" target="_blank" rel="noopener">官方说明</a>）。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>1、<a href="http://webassembly.org/" target="_blank" rel="noopener">http://webassembly.org/</a><br>2、<a href="https://hacks.mozilla.org/2017/02/creating-and-working-with-webassembly-modules/" target="_blank" rel="noopener">Creating and working with WebAssembly modules</a><br>3、<a href="https://hacks.mozilla.org/2017/02/what-makes-webassembly-fast/" target="_blank" rel="noopener">What makes WebAssembly fast?</a><br>4、<a href="https://hacks.mozilla.org/2017/02/a-crash-course-in-just-in-time-jit-compilers/" target="_blank" rel="noopener">A crash course in just-in-time (JIT) compilers</a><br>5、<a href="https://www.lucidchart.com/techblog/2017/05/16/webassembly-overview-so-fast-so-fun-sorta-difficult/" target="_blank" rel="noopener">WEBASSEMBLY OVERVIEW: SO FAST! SO FUN! SORTA DIFFICULT!</a><br>6、<a href="https://zhuanlan.zhihu.com/p/25800318" target="_blank" rel="noopener">WebAssembly 系列 知乎专栏</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">弥生的狗子</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">弥生的狗子</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
